use crate::cargo_toml;
use crate::cycle_breaker::BreakingStrategy;
use std::collections::{HashSet, HashMap};
use std::fs;
use std::path::{Path, PathBuf};

pub struct VariantGenerator {
    original_manifest_path: PathBuf,
    sliced_workspace_dir: PathBuf,
    sliced_crates: HashSet<String>,
    breaking_strategies: Vec<BreakingStrategy>,
    fallback_crates: HashSet<String>,
    use_local_registry: bool,  // Use local registry instead of path dependencies
    crate_versions: HashMap<String, String>,  // Crate name -> version for registry refs
    registry_blocked: HashSet<String>,  // Crates blocked from registry (complex transitive deps)
    registry_crates: HashSet<String>,  // All crates available in the local registry
    sliced_crate_dirs: HashMap<String, String>,  // Crate name -> actual directory name
}

impl VariantGenerator {
    pub fn new(
        manifest: PathBuf,
        workspace: PathBuf,
        sliced: HashSet<String>,
        strategies: Vec<BreakingStrategy>,
        fallback_crates: HashSet<String>,
        use_local_registry: bool,
        crate_versions: HashMap<String, String>,
        registry_blocked: HashSet<String>,
        registry_crates: HashSet<String>,
        sliced_crate_dirs: HashMap<String, String>,
    ) -> Self {
        VariantGenerator {
            original_manifest_path: manifest,
            sliced_workspace_dir: workspace,
            sliced_crates: sliced,
            breaking_strategies: strategies,
            fallback_crates,
            use_local_registry,
            crate_versions,
            registry_blocked,
            registry_crates,
            sliced_crate_dirs,
        }
    }

    /// Generate Cargo.toml.sliced for parent project
    pub fn generate_sliced_variant(&self) -> Result<PathBuf, String> {
        // Parse original manifest
        let content = self.parse_original_manifest()?;

        // Rewrite dependencies section
        let new_content = self.rewrite_dependencies(&content)?;

        // Write to Cargo.toml.sliced
        let output_path = self.original_manifest_path
            .parent()
            .unwrap_or_else(|| Path::new("."))
            .join("Cargo.toml.sliced");

        fs::write(&output_path, new_content)
            .map_err(|e| format!("Failed to write Cargo.toml.sliced: {}", e))?;

        Ok(output_path)
    }

    /// Parse original manifest
    fn parse_original_manifest(&self) -> Result<String, String> {
        fs::read_to_string(&self.original_manifest_path)
            .map_err(|e| format!("Failed to read {}: {}", self.original_manifest_path.display(), e))
    }

    /// Rewrite [dependencies] section with path deps or registry refs
    fn rewrite_dependencies(&self, content: &str) -> Result<String, String> {
        let mut new_content = String::new();

        // Add header comment based on mode
        if self.use_local_registry {
            new_content.push_str("# Generated by cargo-slicer (using local registry)\n");
            new_content.push_str("# This variant uses registry dependencies from .cargo-slicer-registry for caching\n");
            new_content.push_str("# Use with: cargo build --release\n");
            new_content.push_str("# DO NOT EDIT - regenerate with: cargo slicer --use-local-registry\n\n");
        } else {
            new_content.push_str("# Generated by cargo-slicer\n");
            new_content.push_str("# This variant uses path dependencies to sliced crates for faster builds\n");
            new_content.push_str("# Use with: cargo slice build\n");
            new_content.push_str("# DO NOT EDIT - regenerate with: cargo slicer\n\n");
        }

        // First, parse all dependencies from the original manifest using the more robust parser
        let parsed_deps_info = cargo_toml::parse_cargo_toml(
            self.original_manifest_path.parent().unwrap_or_else(|| Path::new(".")),
        ).ok_or_else(|| format!("Failed to parse original Cargo.toml for dependencies: {}", self.original_manifest_path.display()))?;

        // Collect regular dependency names to detect target-specific duplicates
        let mut regular_dep_names: HashSet<String> = HashSet::new();
        for line in content.lines() {
            let t = line.trim();
            if t.starts_with("[dependencies.") {
                let name = t.trim_start_matches("[dependencies.")
                    .trim_end_matches(']')
                    .to_string();
                regular_dep_names.insert(name);
            }
        }

        let lines: Vec<&str> = content.lines().collect();
        let mut in_ignored_section = false;

        for line in lines {
            let trimmed = line.trim();

            // Detect section headers we want to REBUILD (so we skip their original lines)
            // Skip target-specific dependency sections only if they duplicate a regular dep
            let is_regular_dep_section = trimmed.starts_with("[dependencies")
                || trimmed.starts_with("[dev-dependencies")
                || trimmed.starts_with("[build-dependencies");
            let is_target_dup = if trimmed.starts_with("[target.") && trimmed.contains(".dependencies.")
                && !trimmed.contains(".dev-dependencies.") && !trimmed.contains(".build-dependencies.") {
                // Extract dep name from [target.'cfg(...)'.dependencies.NAME]
                if let Some(pos) = trimmed.rfind(".dependencies.") {
                    let dep_name = trimmed[pos + ".dependencies.".len()..].trim_end_matches(']');
                    regular_dep_names.contains(dep_name)
                } else {
                    false
                }
            } else {
                false
            };
            if is_regular_dep_section || is_target_dup {
                in_ignored_section = true;
                continue;
            } else if trimmed.starts_with('[') {
                // Entering a new section we want to KEEP (like [package] or [features])
                in_ignored_section = false;
            }

            if !in_ignored_section {
                // Keep the line (unless it's in a dependency section)
                new_content.push_str(line);
                new_content.push('\n');
            }
        }

        // Now append the REBUILT dependency sections
        new_content.push_str("\n[dependencies]\n# Sliced crates (path dependencies)\n");
        let mut sorted_deps: Vec<(&String, &String)> = parsed_deps_info.dependencies.iter().collect();
        sorted_deps.sort_by_key(|(name, _)| *name);
        for (dep_name, dep_value) in sorted_deps {
            new_content.push_str(&self.format_dependency_line(dep_name, dep_value));
            new_content.push('\n');
        }

        if !parsed_deps_info.dev_dependencies.is_empty() {
            new_content.push_str("\n[dev-dependencies]\n# Sliced dev-crates (path dependencies)\n");
            let mut sorted_dev_deps: Vec<(&String, &String)> = parsed_deps_info.dev_dependencies.iter().collect();
            sorted_dev_deps.sort_by_key(|(name, _)| *name);
            for (dep_name, dep_value) in sorted_dev_deps {
                new_content.push_str(&self.format_dependency_line(dep_name, dep_value));
                new_content.push('\n');
            }
        }

        if !parsed_deps_info.build_dependencies.is_empty() {
            new_content.push_str("\n[build-dependencies]\n# Sliced build-crates (path dependencies)\n");
            let mut sorted_build_deps: Vec<(&String, &String)> = parsed_deps_info.build_dependencies.iter().collect();
            sorted_build_deps.sort_by_key(|(name, _)| *name);
            for (dep_name, dep_value) in sorted_build_deps {
                new_content.push_str(&self.format_dependency_line(dep_name, dep_value));
                new_content.push('\n');
            }
        }

        Ok(new_content)
    }

    /// Helper to format dependency line, handling path deps vs. registry refs
    fn format_dependency_line(&self, crate_name: &str, dep_value: &str) -> String {
        // Always use path dependencies for sliced crates
        if self.should_use_path_dep(crate_name) {
            return self.format_path_dependency(crate_name, dep_value);
        }

        // For pure local registry mode: use registry for non-sliced crates that are available
        if self.use_local_registry
            && self.registry_crates.contains(crate_name)
            && !self.registry_blocked.contains(crate_name) {
            // Use registry reference (pure registry mode)
            return self.format_registry_dependency(crate_name, dep_value);
        }

        // Fall back to original dependencies
        if self.fallback_crates.contains(crate_name) {
            format!("{} = {} # Circular dependency - using registry version", crate_name, dep_value)
        } else {
            cargo_toml::dependency_to_string(crate_name, dep_value)
        }
    }

    /// Format dependency as path reference
    fn format_path_dependency(&self, crate_name: &str, dep_value: &str) -> String {
        // Use absolute path to avoid complex relative path calculations across different drives/roots
        let abs_sliced_dir = fs::canonicalize(&self.sliced_workspace_dir)
            .unwrap_or_else(|_| self.sliced_workspace_dir.clone());

        // Look up the actual directory name (may include version)
        let dir_name = self.sliced_crate_dirs.get(crate_name)
            .cloned()
            .unwrap_or_else(|| format!("{}-sliced", crate_name));
        let path = format!("{}/{}", abs_sliced_dir.display(), dir_name);

        let trimmed_dep_value = dep_value.trim();
        if trimmed_dep_value.starts_with('{') && trimmed_dep_value.ends_with('}') {
            // If original is a table, preserve it and inject path
            let inner_content = &trimmed_dep_value[1..trimmed_dep_value.len() - 1];
            let mut parts: Vec<&str> = inner_content.split(',').collect();

            // Remove existing version/path if present
            parts.retain(|&s| !s.trim().starts_with("version") && !s.trim().starts_with("path"));

            let mut new_table_content = format!("path = \"{}\"", path);
            for part in parts {
                if !part.trim().is_empty() {
                    new_table_content.push_str(&format!(", {}", part.trim()));
                }
            }
            format!("{} = {{ {} }}", crate_name, new_table_content)
        } else {
            // If original is a version string or simple path, convert to path table
            format!("{} = {{ path = \"{}\" }}", crate_name, path)
        }
    }

    /// Format dependency as registry reference
    fn format_registry_dependency(&self, crate_name: &str, dep_value: &str) -> String {
        if let Some(version) = self.crate_versions.get(crate_name) {
            let trimmed_dep_value = dep_value.trim();
            if trimmed_dep_value.starts_with('{') && trimmed_dep_value.ends_with('}') {
                // Preserve features and other attributes
                let inner_content = &trimmed_dep_value[1..trimmed_dep_value.len() - 1];
                let mut parts: Vec<&str> = inner_content.split(',').collect();

                // Remove existing version/path/registry if present
                parts.retain(|&s| {
                    let trimmed = s.trim();
                    !trimmed.starts_with("version")
                        && !trimmed.starts_with("path")
                        && !trimmed.starts_with("registry")
                });

                let mut new_table_content = format!("version = \"{}\", registry = \"cargo-slicer\"", version);
                for part in parts {
                    if !part.trim().is_empty() {
                        new_table_content.push_str(&format!(", {}", part.trim()));
                    }
                }
                format!("{} = {{ {} }}", crate_name, new_table_content)
            } else {
                // Simple version reference
                format!("{} = {{ version = \"{}\", registry = \"cargo-slicer\" }}", crate_name, version)
            }
        } else {
            // Fallback to path if version not found
            self.format_path_dependency(crate_name, dep_value)
        }
    }

    /// Extract crate name from a dependency line
    fn extract_crate_name(&self, line: &str) -> Option<String> {
        // Handle various formats:
        // crate_name = "version"
        // crate_name = { version = "x", features = [...] }
        // crate-name = ...

        let parts: Vec<&str> = line.split('=').collect();
        if parts.len() >= 2 {
            let name = parts[0].trim().to_string();
            return Some(name);
        }

        None
    }

    /// Check if crate should use path dep (not in broken cycle)
    fn should_use_path_dep(&self, crate_name: &str) -> bool {
        self.sliced_crates.contains(crate_name) && !self.fallback_crates.contains(crate_name)
    }

    /// Generate path dependency line for a crate
    fn get_path_dep_line(&self, crate_name: &str, original_line: &str) -> String {
        let path = format!("{}/{}-sliced", self.sliced_workspace_dir.display(), crate_name);

        // Check if original line had features
        let features = self.extract_features(original_line);

        if let Some(features_str) = features {
            format!("{} = {{ path = \"{}\", features = {} }}", crate_name, path, features_str)
        } else {
            format!("{} = {{ path = \"{}\" }}", crate_name, path)
        }
    }

    /// Extract features from original dependency line
    fn extract_features(&self, line: &str) -> Option<String> {
        if let Some(features_start) = line.find("features") {
            // Find the features array
            if let Some(bracket_start) = line[features_start..].find('[') {
                let start_pos = features_start + bracket_start;
                if let Some(bracket_end) = line[start_pos..].find(']') {
                    let end_pos = start_pos + bracket_end + 1;
                    let features = &line[start_pos..end_pos];
                    return Some(features.to_string());
                }
            }
        }
        None
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_extract_crate_name() {
        let gen = VariantGenerator::new(
            PathBuf::from("Cargo.toml"),
            PathBuf::from("sliced_crates"),
            HashSet::new(),
            vec![],
            HashSet::new(),
            false,
            HashMap::new(),
            HashSet::new(),
            HashSet::new(),
            HashMap::new(),
        );

        assert_eq!(gen.extract_crate_name("serde = \"1.0\""), Some("serde".to_string()));
        assert_eq!(gen.extract_crate_name("tokio = { version = \"1.0\", features = [\"full\"] }"), Some("tokio".to_string()));
        assert_eq!(gen.extract_crate_name("proc-macro2 = \"1.0\""), Some("proc-macro2".to_string()));
    }

    #[test]
    fn test_extract_features() {
        let gen = VariantGenerator::new(
            PathBuf::from("Cargo.toml"),
            PathBuf::from("sliced_crates"),
            HashSet::new(),
            vec![],
            HashSet::new(),
            false,
            HashMap::new(),
            HashSet::new(),
            HashSet::new(),
            HashMap::new(),
        );

        let line = "tokio = { version = \"1.0\", features = [\"full\", \"rt\"] }";
        assert_eq!(gen.extract_features(line), Some("[\"full\", \"rt\"]".to_string()));

        let line_no_features = "serde = \"1.0\"";
        assert_eq!(gen.extract_features(line_no_features), None);
    }

    #[test]
    fn test_should_use_path_dep() {
        let mut sliced = HashSet::new();
        sliced.insert("serde".to_string());
        sliced.insert("tokio".to_string());

        let mut fallback = HashSet::new();
        fallback.insert("tokio".to_string());

        let gen = VariantGenerator::new(
            PathBuf::from("Cargo.toml"),
            PathBuf::from("sliced_crates"),
            sliced,
            vec![],
            fallback,
            false,
            HashMap::new(),
            HashSet::new(),
            HashSet::new(),
            HashMap::new(),
        );

        assert!(gen.should_use_path_dep("serde"));  // Sliced, not in fallback
        assert!(!gen.should_use_path_dep("tokio")); // Sliced but in fallback
        assert!(!gen.should_use_path_dep("rand"));  // Not sliced
    }
}
